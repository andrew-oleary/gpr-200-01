//Andrew O'Leary
//gpr200-01
//final pScene vs

#version 450

//reading geometric data: attributes
layout(location=0)
	in vec4 aPosition;

//another attribute: normal
layout(location=1)
	in vec3 aNormal;
	
uniform sampler2D uTexture;	
layout (location=2)
 in vec2 aTexcoord;
//ModleMatrix	
uniform mat4 uModelMat;
//camera
uniform mat4 u_ViewProjection;
// varying
out vec4 vColor;
out vec2 texCoord;

struct sPointLight
{
vec4 center;
vec4 color;
float intensity;
};
sPointLight newPointLight(vec3 center,vec3 color,float intensity)
{
sPointLight pointLight;
pointLight.center=vec4(center,1.0);
pointLight.color=vec4(color,1.0);
pointLight.intensity=intensity;
return pointLight;
}


//cal shading
vec4 calcPhong(sPointLight pointLight,vec4 vCoord,vec4 mCoord,vec4 color)
{
	vec3 norm=normalize(aNormal);
	vec3 lNorm=	normalize(pointLight.center.xyz-mCoord.xyz);
	float dif= max(dot(lNorm,norm),0.0);//diffuse
	 float d=dot(vCoord,pointLight.center);
       float IL=d/pointLight.intensity;
       float IL2=pow(d,2.0)/pow(pointLight.intensity,2.0);
       float attenuation=(1.0/(1.0+IL+IL2));
       
       vec3 vV= normalize(vCoord.xyz-mCoord.xyz);            //view vector
 	   vec3 rL= reflect( -lNorm,aNormal);                     //reflected light vector
       float k=max(0.0,dot(vV,rL));
	   float hL= 3;
      
       k=pow(k,hL);
       vec3 specular=0.3*k*pointLight.color.xyz;
       return vec4((attenuation+dif+specular)*color.xyz,color.w);
}
void main()
{
//object-> world -> camera -> frustum (clip)
gl_Position=u_ViewProjection* uModelMat*aPosition;
vColor=aPosition*0.5+0.5;
//light
sPointLight pointLight;
pointLight=newPointLight(vec3(0.8,0.0,0.0),vec3(2.3,2.0,2.0),16.0);
vec4 fragPos=vec4(uModelMat*aPosition);
vec4 finalColor=calcPhong(pointLight,gl_Position,fragPos,vec4(1.0,0.70,0.5,1.0));
vColor=finalColor;
texCoord=aTexcoord;
}